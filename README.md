# internet-algorithms
course 3

**TASK 1:**

Булева модель ИП. Построение инвертированного индекса

Напишите программу на Java, которая реализует простейший вариант булевой модели информационного поиска. В архиве содержатся тексты пьес Шекспира (исходные тексты взяты с сайта http://shakespeare.mit.edu/). Документы из архива необходимо поместить в отдельную папку проекта, проиндексировать с помощью написанной программы, а затем выполнить запросы по вашему варианту. Программа должна уметь обрабатывать различные виды запросов (см. примеры).

    Реализуйте класс InvertedIndex для работы с инвертированным индексом.
    Метод public void indexDocument(String path): индексирует документ, находящийся по пути path. При обработке текста нужно избавиться от не алфавитно-цифровых символов, а также привести термы к нижнему регистру.
    Для тестирования работы метода проиндексируйте файл collection\King_Lear.txt, должен получиться следующий результат. Обратите внимание, что размер индекса должен совпадать со значением из примера.

    |     0  | collection\King_Lear.txt                                     |     3997  |   
       

    Метод public void indexCollection(String folder): индексирует коллекцию документов, которые находятся в папке folder.
    Проверьте работу метода на документах из папки collection. После запуска программы, вы должны увидеть примерно следующий результат (размер индекса должен совпадать!):

    +--------+--------------------------------------------------------------+-----------+
    | docID  | file                                                         | indexsize |
    +--------+--------------------------------------------------------------+-----------+
    |     0  | collection\All_s_Well_That_Ends_Well.txt                     |     3379  |
    |     1  | collection\Antony_and_Cleopatra.txt                          |     5492  |
    |     2  | collection\As_You_Like_It.txt                                |     6734  |
    |     3  | collection\A_Midsummer_Night_s_Dream.txt                     |     7696  |
    |     4  | collection\Cymbeline.txt                                     |     8548  |
    |     5  | collection\King_Lear.txt                                     |     9661  |
    |     6  | collection\Loves_Labours_Lost.txt                            |    10688  |
    |     7  | collection\Measure_for_Measure.txt                           |    11029  |
    |     8  | collection\Much_Ado_About_Nothing.txt                        |    11524  |
    |     9  | collection\Othello_the_Moore_of_Venice.txt                   |    12179  |
    |    10  | collection\Pericles,_Prince_of_Tyre.txt                      |    12692  |
    |    11  | collection\Romeo_and_Juliet.txt                              |    13179  |
    |    12  | collection\The_Comedy_of_Errors.txt                          |    13519  |
    |    13  | collection\The_First_part_of_King_Henry_the_Fourth.txt       |    14210  |
    |    14  | collection\The_First_part_of_King_Henry_the_Sixth.txt        |    14840  |
    |    15  | collection\The_Life_and_Death_of_Julies_Caesar.txt           |    15139  |
    |    16  | collection\The_Life_and_Death_of_King_John.txt               |    15530  |
    |    17  | collection\The_Life_and_Death_of_Richard_the_Second.txt      |    15922  |
    |    18  | collection\The_Life_and_Death_of_Richard_the_Third.txt       |    16119  |
    |    19  | collection\The_Life_of_King_Henry_the_Eight.txt              |    16508  |
    |    20  | collection\The_Life_of_King_Henry_the_Fifth.txt              |    17047  |
    |    21  | collection\The_Merchant_of_Venice.txt                        |    17268  |
    |    22  | collection\The_Merry_Wives_of_Windsor.txt                    |    17755  |
    |    23  | collection\The_Second_part_of_King_Henry_the_Fourth.txt      |    18184  |
    |    24  | collection\The_Second_part_of_King_Henry_the_Sixth.txt       |    18580  |
    |    25  | collection\The_Taming_of_the_Shrew.txt                       |    18800  |
    |    26  | collection\The_Tempest.txt                                   |    19102  |
    |    27  | collection\The_Third_part_of_King_Henry_the_Sixth.txt        |    19350  |
    |    28  | collection\The_Tragedy_of_Coriolanus.txt                     |    19789  |
    |    29  | collection\The_Tragedy_of_Hamlet_Prince_of_Denmark.txt       |    20152  |
    |    30  | collection\The_Tragedy_of_Macbeth.txt                        |    20447  |
    |    31  | collection\Timon_of_Athens.txt                               |    20692  |
    |    32  | collection\Titus_Andronicus.txt                              |    20818  |
    |    33  | collection\Troilus_and_Cressida.txt                          |    21092  |
    |    34  | collection\Twelfth_Night.txt                                 |    21351  |
    |    35  | collection\Two_Gentlemen_of_Verona.txt                       |    21481  |
    |    36  | collection\Winter_s_Tale.txt                                 |    21810  |
    +--------+--------------------------------------------------------------+-----------+

    Метод public LinkedList<Integer> getIntersection(LinkedList<Integer> list1, LinkedList<Integer> list2), который возвращает пересечение двух списков словопозиций (см. алгоритм построения пересечения в лекции). Обратите внимание, что при реализации данного алгоритма для обхода списков логично воспользоваться итераторами.
    Метод public LinkedList<Integer> getUnion(LinkedList<Integer> list1, LinkedList<Integer> list2), который возвращает объединение двух списков словопозиций (см. лекцию).
    Метод public LinkedList<Integer> executeQuery(String query), который выполняет запросы следующих типов:
        простой запрос, состоящий из одного терма, например "Caesar";
        запрос, состоящий из многоместной конъюнкции термов, например "Caesar AND Brutus AND Calpurnia" (для произвольного количества слов);
        запрос, состоящий из многоместной дизъюнкции термов, например "Caesar OR Brutus OR Calpurnia" (для произвольного количества слов).
    Протестируйте выполнение различных типов запросов (в том числе и запросы, на которые должен вернуться пустой список). Выведите списки документов, соответствующих данным запросам.
        Brutus [1, 15, 20, 21, 24, 28, 29]
        Caesar [0, 1, 2, 4, 6, 7, 9, 14, 15, 17, 18, 22, 23, 24, 27, 29, 30, 32]
        Calpurnia [15]
        Brutus AND Brutus [1, 15, 20, 21, 24, 28, 29]
        Brutus AND Caesar [1, 15, 24, 29]
        Brutus AND Caesar AND Calpurnia [15]
        Brutus OR Brutus [1, 15, 20, 21, 24, 28, 29]
        Brutus OR Caesar [0, 1, 2, 4, 6, 7, 9, 14, 15, 17, 18, 20, 21, 22, 23, 24, 27, 28, 29, 30, 32]
        Brutus OR Caesar OR Calpurnia [0, 1, 2, 4, 6, 7, 9, 14, 15, 17, 18, 20, 21, 22, 23, 24, 27, 28, 29, 30, 32]
        SpiderMan []
        Brutus AND SpiderMan []
        Caesar OR SpiderMan [0, 1, 2, 4, 6, 7, 9, 14, 15, 17, 18, 22, 23, 24, 27, 29, 30, 32]
    Преобразуйте метод indexCollection() таким образом, чтобы он выполнял рекурсивный обход и индексирование указанной папки.
    Используйте сериализацию для хранения копии созданного экземпляра класса InvertedIndex в файле. При повторном запуске программы считывайте построенный индекс из файла.

    
**TASK 2:**


Булева модель ИП. Инвертированный индекс — 2

Расширьте функциональные возможности класса InvertedIndex (см. предыдущую лабораторную работу).

При выполнении лабораторной работы для индексации используйте коллекцию HTML-документов.

    Внесите изменения в метод indexDocument, чтобы он мог индексировать не только текстовые документы (text/plain), но и HTML-страницы (text/html) в зависимости от MIME-типа файла. При индексации HTML-документа нужно обрабатывать только содержимое элемента body, при этом игнорируя HTML-теги. Для решения этой подзадачи можно использовать HTML-парсер jsoup.
    Реализуйте возможность индексировать не только файлы, расположенные на жестком диске вашего компьютера, но и файлы опубликованные на веб-серверах (см. документацию проекта jsoup).
    Добавьте обработку стоп-слов в класс InvertedIndex, создайте конструктор в классе InvertedIndex, которому в качестве параметра должен передаваться путь к файлу со стоп-словами. В методах индексации документа (indexDocument) и обработки запроса (executeQuery) при получении очередного терма нужно проверить является ли он стоп-словом, и если да, то не вносить его в индекс и не обрабатывать в запросе.
    В методах индексации документа (indexDocument) и обработки запроса (executeQuery) добавьте обработку термов с помощью алгоритма стемминга Портера, см. библиотеку Snowball.
    Выполните несколько поисковых запросов и проверьте корректность их выполнения
        не менее 4 простых, в том числе запрос, содержащий стоп-слово, и запросы с различными формами одного слова
        не менее 4 конъюнктивных запросов различной длины (от 2 до 5 термов). В том числе и запрос, содержащий стоп-слово
        не менее 4 дизъюнктивных запросов различной длины (от 2 до 5 термов). В том числе и запрос, содержащий стоп-слово

**TASK 3:**

Сжатие списка словопозиций

    Реализуйте библиотеку методов для выполнения кодирования и декодирования списков интервалов по вашему варианту.
    Продемонстрируйте работу реализованных методов.
    Внесите изменения в ранее реализованный класс InvertedIndex так, чтобы он хранил не списки идентификаторов документов, а коды интервалов.
    Сравните размеры сериализованного индекса до применения кодирования и после.

Битовое кодирование (γ-код)
Библиотека должна включать следующие методы:

    BitSet listBitEncode(List<Integer> list) – метод кодирования последовательности интервалов в последовательность бит (для хранения цепочки бит можно использовать класс BitSet Объект типа BitSet хранит значение типа boolean для каждого бита по индексу, при приведении объекта к строке перечисляются индексы бит, равных true (1)).
    List<Integer> bitDecode(BitSet list) – декодирование последовательности бит в последовательность интервалов.
    List<Integer> toIntervals(List<Integer> list) – вспомогательный метод преобразования списков словопозиций в список интервалов.
    List<Integer> toDocIds(List<Integer> list) – вспомогательный метод преобразования списков интервалов в список словопозиций.

Пример кодирования данных

Исходные данные -- список словопозиций: [1010, 1012, 1020, 1050]
Список интервалов (по списку словопозиций): [1010, 2, 8, 30] 
Закодированная последовательность (по списку интервалов): {0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 11, 12, 13, 14, 17, 19, 22, 23, 24, 29, 30, 31, 32, 34, 35, 36}
Декодированная последовательность: [1010, 2, 8, 30] 
Список словопозиций (по декодированной последовательности): [1010, 1012, 1020, 1050]

